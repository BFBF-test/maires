name: Mise Ã  jour quotidienne des articles Maire-Info

on:
  schedule:
    # Deux scans par jour, du lundi au vendredi
    # 8h00 Paris (= 7h00 UTC en hiver CET / 6h00 UTC en Ã©tÃ© CEST)
    - cron: '0 7 * * 1-5'
    # 14h00 Paris (= 13h00 UTC en hiver / 12h00 UTC en Ã©tÃ©)
    - cron: '0 13 * * 1-5'
  workflow_dispatch:  # DÃ©clenchement manuel possible

permissions:
  contents: write

jobs:
  update-articles:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout du dÃ©pÃ´t
        uses: actions/checkout@v4

      - name: Configuration de Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: RÃ©cupÃ©ration et traitement des articles
        id: scrape
        uses: actions/github-script@v7
        with:
          script: |
            const https = require('https');
            const http = require('http');
            const fs = require('fs');

            // === CONFIGURATION ===
            const RSS_URL = 'http://www.maire-info.com/rss/';
            const MAX_ARTICLES = 500;

            // === FONCTIONS UTILITAIRES ===

            function fetch(url) {
              return new Promise((resolve, reject) => {
                const client = url.startsWith('https') ? https : http;
                client.get(url, {
                  headers: { 'User-Agent': 'MaireInfoArchiver/1.0' },
                  timeout: 15000
                }, (res) => {
                  if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
                    return fetch(res.headers.location).then(resolve).catch(reject);
                  }
                  let data = '';
                  res.setEncoding('utf8');
                  res.on('data', chunk => data += chunk);
                  res.on('end', () => resolve(data));
                  res.on('error', reject);
                }).on('error', reject);
              });
            }

            function decodeHtmlEntities(str) {
              return str
                .replace(/&rsquo;/g, '\u2019').replace(/&laquo;/g, '\u00AB').replace(/&raquo;/g, '\u00BB')
                .replace(/&eacute;/g, 'Ã©').replace(/&egrave;/g, 'Ã¨').replace(/&agrave;/g, 'Ã ')
                .replace(/&ugrave;/g, 'Ã¹').replace(/&ecirc;/g, 'Ãª').replace(/&ocirc;/g, 'Ã´')
                .replace(/&icirc;/g, 'Ã®').replace(/&ucirc;/g, 'Ã»').replace(/&acirc;/g, 'Ã¢')
                .replace(/&euml;/g, 'Ã«').replace(/&iuml;/g, 'Ã¯').replace(/&ouml;/g, 'Ã¶')
                .replace(/&uuml;/g, 'Ã¼').replace(/&ccedil;/g, 'Ã§')
                .replace(/&Eacute;/g, 'Ã‰').replace(/&Egrave;/g, 'Ãˆ').replace(/&Agrave;/g, 'Ã€')
                .replace(/&Ecirc;/g, 'ÃŠ').replace(/&Ocirc;/g, 'Ã”')
                .replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>')
                .replace(/&quot;/g, '"').replace(/&#0?39;/g, "'").replace(/&nbsp;/g, ' ')
                .replace(/&ndash;/g, 'â€“').replace(/&mdash;/g, 'â€”').replace(/&hellip;/g, 'â€¦')
                .replace(/&oelig;/g, 'Å“').replace(/&OElig;/g, 'Å’');
            }

            function stripCDATA(str) { return str.replace(/<!\[CDATA\[([\s\S]*?)\]\]>/g, '$1'); }
            function stripHtml(str) { return str.replace(/<[^>]+>/g, '').trim(); }

            function extractTag(xml, tag) {
              const regex = new RegExp(`<${tag}[^>]*>([\\s\\S]*?)</${tag}>`, 'i');
              const match = xml.match(regex);
              return match ? match[1].trim() : '';
            }

            function extractIdFromUrl(url) {
              const match = url.match(/param=(\d+)/);
              return match ? parseInt(match[1]) : 0;
            }

            function isoDate(pubDate) {
              try {
                const d = new Date(pubDate);
                return isNaN(d.getTime()) ? new Date().toISOString().slice(0, 10) : d.toISOString().slice(0, 10);
              } catch(e) { return new Date().toISOString().slice(0, 10); }
            }

            function parseRSS(xml) {
              const items = [];
              const itemRegex = /<item>([\s\S]*?)<\/item>/gi;
              let match;
              while ((match = itemRegex.exec(xml)) !== null) {
                const itemXml = match[1];
                const title = decodeHtmlEntities(stripCDATA(extractTag(itemXml, 'title')));
                const link = extractTag(itemXml, 'link').trim();
                const descRaw = stripCDATA(extractTag(itemXml, 'description'));
                const description = decodeHtmlEntities(stripHtml(descRaw)).replace(/\s+/g, ' ').trim();
                const pubDate = extractTag(itemXml, 'pubDate');
                if (title && link) {
                  items.push({ id: extractIdFromUrl(link), title, description: description.slice(0, 500), url: link, date: isoDate(pubDate), rubrique: '' });
                }
              }
              return items;
            }

            async function fetchRubrique(articleUrl) {
              try {
                const html = await fetch(articleUrl);
                const rubriqueMatch = html.match(/refer=listerubriques[^"]*"[^>]*>([^<]+)</i);
                if (rubriqueMatch) return decodeHtmlEntities(rubriqueMatch[1].trim());
                const pathMatch = articleUrl.match(/maire-info\.com\/([^\/]+)\//);
                if (pathMatch) return decodeHtmlEntities(pathMatch[1].replace(/-/g, ' ').replace(/^\w/, c => c.toUpperCase()));
                return '';
              } catch(e) { return ''; }
            }

            // === LOGIQUE PRINCIPALE ===

            async function main() {
              const report = { status: 'success', rssArticles: 0, newArticles: 0, totalArticles: 0, titles: [], error: '' };

              console.log('ðŸ“° RÃ©cupÃ©ration du flux RSS...');
              let rssXml;
              try {
                rssXml = await fetch(RSS_URL);
                console.log(`âœ… Flux RSS rÃ©cupÃ©rÃ© (${rssXml.length} car.)`);
              } catch(e) {
                report.status = 'error';
                report.error = e.message;
                core.setOutput('report', JSON.stringify(report));
                core.setFailed(`Erreur RSS : ${e.message}`);
                return;
              }

              const newArticles = parseRSS(rssXml);
              report.rssArticles = newArticles.length;
              console.log(`ðŸ“‹ ${newArticles.length} article(s) dans le RSS`);

              if (newArticles.length === 0) {
                report.status = 'no_new';
                core.setOutput('report', JSON.stringify(report));
                return;
              }

              console.log('ðŸ·ï¸ RÃ©cupÃ©ration des rubriques...');
              for (const article of newArticles) {
                article.rubrique = await fetchRubrique(article.url);
                console.log(`  â€¢ "${article.title.slice(0,60)}..." â†’ ${article.rubrique || '?'}`);
                await new Promise(r => setTimeout(r, 500));
              }

              let existingArticles = [];
              try {
                const indexHtml = fs.readFileSync('index.html', 'utf-8');
                const dataMatch = indexHtml.match(/const ARTICLES = (\[[\s\S]*?\]);/);
                if (dataMatch) existingArticles = JSON.parse(dataMatch[1]);
                console.log(`ðŸ“¦ ${existingArticles.length} article(s) en archives`);
              } catch(e) { console.log('â„¹ï¸ CrÃ©ation initiale.'); }

              const existingIds = new Set(existingArticles.map(a => a.id));
              let addedCount = 0;
              for (const article of newArticles) {
                if (!existingIds.has(article.id)) {
                  existingArticles.push(article);
                  existingIds.add(article.id);
                  addedCount++;
                  report.titles.push(article.title);
                }
              }

              report.newArticles = addedCount;
              console.log(`âž• ${addedCount} nouvel(aux) article(s)`);

              existingArticles.sort((a, b) => {
                if (a.date !== b.date) return b.date.localeCompare(a.date);
                return b.id - a.id;
              });

              if (existingArticles.length > MAX_ARTICLES) {
                existingArticles = existingArticles.slice(0, MAX_ARTICLES);
              }

              report.totalArticles = existingArticles.length;

              let indexHtml = fs.readFileSync('index.html', 'utf-8');
              const now = new Date().toISOString();
              indexHtml = indexHtml.replace(/const ARTICLES = \[[\s\S]*?\];/, `const ARTICLES = ${JSON.stringify(existingArticles, null, 2)};`);
              indexHtml = indexHtml.replace(/const LAST_UPDATE = "[^"]*";/, `const LAST_UPDATE = "${now}";`);
              fs.writeFileSync('index.html', indexHtml, 'utf-8');

              console.log(`âœ… index.html mis Ã  jour â€” ${existingArticles.length} articles`);
              core.setOutput('report', JSON.stringify(report));
            }

            await main();

      - name: Commit et push
        id: commit
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add index.html
          if git diff --staged --quiet; then
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            ARTICLES_COUNT=$(grep -o '"id"' index.html | wc -l)
            DATE=$(TZ='Europe/Paris' date +%Y-%m-%d)
            HOUR=$(TZ='Europe/Paris' date +%Hh%M)
            git commit -m "ðŸ“° $DATE $HOUR â€” $ARTICLES_COUNT articles en archives"
            git push
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      #  NOTIFICATION PAR EMAIL
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      - name: PrÃ©parer le rapport email
        id: email
        if: always()
        run: |
          REPORT='${{ steps.scrape.outputs.report }}'
          DATE=$(TZ='Europe/Paris' date '+%d/%m/%Y Ã  %Hh%M')
          CHANGED="${{ steps.commit.outputs.changed }}"

          # --- Statut et sujet ---
          if [ "${{ job.status }}" = "failure" ]; then
            SUBJECT="âŒ Maire-Info Archives â€” Ã‰chec du scan ($DATE)"
            STATUS="Ã‰CHEC"
          elif [ "$CHANGED" = "true" ]; then
            NEW=$(echo "$REPORT" | jq -r '.newArticles // 0' 2>/dev/null || echo "?")
            SUBJECT="âœ… Maire-Info Archives â€” $NEW nouvel(aux) article(s) ($DATE)"
            STATUS="OK â€” nouveaux articles ajoutÃ©s"
          else
            SUBJECT="â„¹ï¸ Maire-Info Archives â€” RAS ($DATE)"
            STATUS="OK â€” rien de nouveau"
          fi

          # --- DonnÃ©es du rapport ---
          RSS=$(echo "$REPORT" | jq -r '.rssArticles // 0' 2>/dev/null || echo "?")
          NEW=$(echo "$REPORT" | jq -r '.newArticles // 0' 2>/dev/null || echo "0")
          TOTAL=$(echo "$REPORT" | jq -r '.totalArticles // 0' 2>/dev/null || echo "?")
          ERR=$(echo "$REPORT" | jq -r '.error // ""' 2>/dev/null || echo "")

          # --- Liste des nouveaux titres ---
          TITLES=$(echo "$REPORT" | jq -r '.titles[]?' 2>/dev/null | while IFS= read -r t; do echo "  â€¢ $t"; done)
          [ -z "$TITLES" ] && TITLES="  (aucun)"

          # --- Corps du mail ---
          EOF_MARKER=$(head -c 32 /dev/urandom | base64 | tr -d '/+=' | head -c 16)

          echo "subject=$SUBJECT" >> $GITHUB_OUTPUT

          cat >> $GITHUB_OUTPUT <<GHEOF
          body<<$EOF_MARKER
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           RAPPORT DE SCAN MAIRE-INFO
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

          Date :   $DATE
          Statut : $STATUS
          $( [ -n "$ERR" ] && echo "Erreur : $ERR" )

          â”€â”€ Chiffres â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          Articles dans le RSS :       $RSS
          Nouveaux articles ajoutÃ©s :  $NEW
          Total en archives :          $TOTAL

          â”€â”€ Nouveaux articles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          $TITLES

          â”€â”€ Liens â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          Workflow : ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          Prochains scans : 8h et 14h (Paris)
          $EOF_MARKER
          GHEOF

      - name: Envoyer l'email de confirmation
        if: always()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.SMTP_SERVER }}
          server_port: ${{ secrets.SMTP_PORT }}
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}
          to: ${{ secrets.NOTIFICATION_EMAIL }}
          from: Maire-Info Archives <${{ secrets.SMTP_USERNAME }}>
          subject: ${{ steps.email.outputs.subject }}
          body: ${{ steps.email.outputs.body }}
          secure: true
